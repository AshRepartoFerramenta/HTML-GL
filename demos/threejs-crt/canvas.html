<!--

API
changeText
changeTextColor
changeTextSize
changeBackckgroundColor
record
restart
save

-->


<!DOCTYPE html>
<html lang="en">
<head>
    <title>HTML GL CRT emulation</title>
    <meta name="viewport" content="width=1024 maximum-scale=1.0 minimum-scale=1.0 initial-scale=1.0, user-scalable=no" />

    <script src="../../node_modules/three/build/three.min.js"></script>
    <script src='./lib/dat.gui.min.js'></script>

    <script src="../../dist/html-gl.js" renderer="three"></script>
    <script src="./lib/shaders/CopyShader.js"></script>
    <script src="./lib/shaders/FXAAShader.js"></script>
    <script src="./lib/shaders/ConvolutionShader.js"></script>
    <script src="./lib/shaders/RGBShiftShader.js"></script>
    <script src="./lib/shaders/LuminosityHighPassShader.js"></script>
    <script src="./lib/shaders/FilmShader.js"></script>
    <script src="./lib/shaders/DigitalGlitch.js"></script>
    <script src="./lib/postprocessing/EffectComposer.js"></script>
    <script src="./lib/postprocessing/RenderPass.js"></script>
    <script src="./lib/postprocessing/MaskPass.js"></script>
    <script src="./lib/postprocessing/ShaderPass.js"></script>
    <script src="./lib/postprocessing/GlitchPass.js"></script>
    <script src="./lib/postprocessing/FilmPass.js"></script>
    <script src="./lib/postprocessing/UnrealBloomPass.js"></script>
    <script src="./lib/gl-gif.js"></script>
    <link rel="stylesheet" href="style/canvas.css">
</head>

<body>
<div>
    <html-gl>
        <h1 id="text">
            Hello world!</br>I am a cybertext.
        </h1>
        <div>
            <p>Should be transparent</p>
        </div>
    </html-gl>
</div>
<div id="progressBar"></div>
</body>
<script>
    var total = left = 48;
    var container, stats;
    var params = {
        projection: 'normal',
        background: false,
        exposure: 1.0,
        bloomThreshold: 0.82,
        bloomStrength: 2.2,
        bloomRadius: 0.86,
        rgbShift: 0.0075,
    };

    var rtParameters = {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBAFormat,
        stencilBuffer: true
    };

    var camera, renderer, controls, objects = [];
    var clock, effectFXAA, bloomPass, renderScene, effectRGB, filmPass, glitchPass, gifRecorder, gifImage;
    var composer;
    var standardMaterial;
    var renderer = HTMLGL.renderer.view.engineRenderer;

    init();
    render();

    var resolveRecordingCallback = null;

    function record() {
        return new Promise(function(resolve){
            gifRecorder = GIF(HTMLGL.renderer.view.engineRenderer.context, {
                fps: 24,
                quality: 0,
                dither: true,
                repeat: 0,
            });

            resolveRecordingCallback = resolve;
        });
    }

    gifImage = new Image();
    gifImage.style.position = 'absolute';
    gifImage.style.top = 0;
    gifImage.style.left = 0;
    document.body.appendChild(gifImage);
    gifImage.style.transformOrigin = "0 0";

    var imageScale = 1 / window.devicePixelRatio;
    gifImage.style.transform = `scale(${imageScale}, ${imageScale})`;

    function init() {

        clock = new THREE.Clock();

        HTMLGL.scene.add( new THREE.AmbientLight( 0x222222 ) );

        var spotLight = new THREE.SpotLight( 0xffffff );
        spotLight.position.set( 50, 100, 50 );
        spotLight.angle = Math.PI / 7;
        spotLight.penumbra = 0.8;
        spotLight.castShadow = true;
        HTMLGL.scene.add( spotLight );

        renderScene = new THREE.RenderPass(HTMLGL.scene, HTMLGL.camera);

        //renderScene.clear = true;

        var copyShader = new THREE.ShaderPass(THREE.CopyShader);
        copyShader.renderToScreen = true;

        filmPass = new THREE.FilmPass( 0.35, 0.025, 200, false );

        bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), params.bloomStrength, params.bloomRadius, params.bloomThreshold);//1.0, 9, 0.5, 512);

        composer = new THREE.EffectComposer(HTMLGL.renderer.view.engineRenderer);
        composer.setSize(window.innerWidth, window.innerHeight);
        composer.addPass(renderScene);

        glitchPass = new THREE.GlitchPass(64);

        effectRGB = new THREE.ShaderPass(THREE.RGBShiftShader);
        effectRGB.uniforms[ 'amount' ].value = 0.0025;
        effectRGB.uniforms[ 'angle' ].value = 3.14 / 4;
        composer.addPass(effectRGB);
        composer.addPass(glitchPass);
        composer.addPass(bloomPass);

        composer.addPass(filmPass);
        composer.addPass(copyShader);

        //renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.gammaInput = true;
        renderer.gammaOutput = true;

        var gui = new dat.GUI();

        gui.add( params, 'bloomThreshold', 0.0, 1.0 ).onChange( function(value) {
            bloomPass.threshold = Number(value);
        });
        gui.add( params, 'bloomStrength', 0.0, 3.0 ).onChange( function(value) {
            bloomPass.strength = Number(value);
        });
        gui.add( params, 'bloomRadius', 0.0, 1.0 ).onChange( function(value) {
            bloomPass.radius = Number(value);
        });
        gui.add( params, 'rgbShift', 0.0, 0.01 ).onChange( function(value) {
            effectRGB.uniforms[ 'amount' ].value = Number(value);
        });
        gui.open();
    }

    function render() {
        composer.render(clock.getDelta());

        if (gifRecorder) {
            gifRecorder.tick();
            left = left - 1;
            var t = 1 - (left / total);
            console.log(left);

            var progressIndicator = document.getElementById('progressBar');
            progressIndicator.style.transform = `scaleX(${t})`;

            if (t > 1 && !gifImage.src.length) {
                gifImage.src = gifRecorder.done();
                gifImage.style.zIndex = 9999;
                resolveRecordingCallback();
            } else {
                requestAnimationFrame( render );
            }
        } else {
            requestAnimationFrame( render );
        }
    }

    function changeTextColor(color) {
        var text = document.getElementById('text');
        text.style.color = color;
        HTMLGL.renderer.view.updateTextures();
    }

    function changeBackgroundColor(color) {
        HTMLGL.renderer.view.engineRenderer.setClearColor(color, 1);
    }
</script>
</html>